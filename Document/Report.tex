\documentclass{article}
\usepackage{amsfonts}
\usepackage{cite}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\newcommand{\ignore}[1]{}
\author{\textbf{Erick Bauman} \\ exb131030@utdallas.edu \\\textbf{Tristan Duckworth} \\ txd123130@utdallas.edu \\\textbf{Shamila Wickramasuriya} \\ scw130030@utdallas.edu}
\title{\huge{Language-Based Security Final Project Report} \\ \LARGE{FeatherEvaluator}}
\begin{document}
\maketitle

\section{Project Motivation}

Popular languages today have many vulnerabilities, especially higher-level languages that intend to make life easier for developers and prevent them from making common mistakes.  Java, which provides a safer environment to program in than C or C++, nevertheless has a large and complex runtime program with its own share of vulnerabilities.  The high complexity of a modern language can benefit from formalization so that properties of both the core semantics and a runtime implementation can be proved to behave as intended.  Unfortunately, Java is complex, and we are far from having a fully validated JRE.

However, it is possible to take a first step in this direction.  A formal definition of the core syntax of Java exists in the form of Featherweight Java\cite{igarashi2001featherweight}, which has allowed proofs to be made demonstrating certain properties of Java.  This omits many of the features of Java, such as assignment, base types, and access control.  However, this simplification makes proofs much more feasible.

Several Coq implementations of Featherweight Java have been written, allowing for proofs to be machine-checked~\cite{mackay2012encoding, delaware2011product,castfree}.  Unfortunately, the implementations available only provide definitions of evaluating Featherweight Java expressions in a propositional form.  While practical for use in proofs, these implementations do not provide a functional implementation, which would be useful for eventually proving the correctness of an actual Java runtime.  While eventually it would be practical to prove the correct behavior of a functional implementation that evaluates Java bytecode instead of source code, we wanted to focus on demonstrating and proving the soundness of a functional implementation of the Featherweight Java semantics in Coq.

\section{Accomplishments}

We implemented a function to evaluate the small-step semantics of Featherweight Java, based on a cast-free implementation of Featherweight Java\cite{castfree}.

We wrote part of a proof of soundness of our function, which stated that for any expression, if our implementation produced a resulting expression, then the propositional evaluation would hold:

\texttt{
forall (e1 e2:fexp) (fct:fctable),
}

\texttt{
    feval e1 fct = Some e2 -> eval (fexp2exp e1) (fexp2exp e2).
}

\section{Project Summary}

\subsection{Overview}

Since we could start with an existing Featherweight Java implementation, the process of proving that the functional implementation was ``correct'' meant proving that for any expression, if our function produces a resulting expression, then the original propositional implementation holds for that expression.  Since the propositional implementation has already been proved correct by the original authors, this is sufficient to prove soundness (but not completeness) of the function.

We discovered that the original representation of expressions was not well-suited to computation. In particular, the congruence rules that specify how expressions used as arguments are reduced allow any argument to be reduced at a given time. Since the original implementation of expressions, \texttt{exp}, made use of lists to represent collections of arguments, we were unable to write proofs when they depended on the reduction of these arguments. In light of this, we implemented a new representation, \texttt{fexp}, that can be readily translated to \texttt{exp} (for the sake of writing proofs with respect to the propositional definitions of evaluation) and does not represent arguments as a list (allowing us to reason about the computations we perform).

Our work currently consists of three major source files:

\begin{itemize}
	\item \texttt{FEV\_Definitions.v} contains the definition of \texttt{fexp} and \texttt{fexp2exp}, redefines some of the original definitions (such as that for class tables) in terms of \texttt{fexp} rather than \texttt{exp}, adds some supporting functions for evaluation, and finally contains \texttt{feval} itself. As a bonus, it contains a function \texttt{teval} that evaluates any \texttt{fexp} with \texttt{feval} until no more progress can be made.
	
	\item \texttt{FEV\_Properties.v} contains auxiliary lemmas for reasoning about lists and our supporting functions as well as the (incomplete) proof of soundness.
	
	\item \texttt{FEV\_Example.v} contains an example of a computation being performed on a simple \texttt{fexp} as well as a great number of old examples meant for a version of our evaluator that targeted \texttt{exp} instead.
\end{itemize}

\subsection{Difficulties}

\section{Team Coordination}

\section{Future Work}

\bibliography{Report}{}
\bibliographystyle{plain}

\end{document}